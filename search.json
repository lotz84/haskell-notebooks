[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "IHaskellã§æ›¸ã„ãŸnotebookã‚’å…¬é–‹ã™ã‚‹å ´æ‰€\nZennã«ã‚‚è¨˜äº‹ã‚’æ›¸ã„ã¦ã„ã¾ã™\nhttps://zenn.dev/lotz"
  },
  {
    "objectID": "posts/2020-07-11/index.html",
    "href": "posts/2020-07-11/index.html",
    "title": "é«˜æ¬¡å…ƒç©ºé–“ã§ã¯L1è·é›¢ã‚’ä½¿ã†ã®ãŒè‰¯ã•ãã†",
    "section": "",
    "text": "â€œOn the Surprising Behavior of Distance Metrics in High Dimensional Spacesâ€ã¨ã„ã†è«–æ–‡ã‚’èª­ã‚“ã§é¢ç™½ã‹ã£ãŸã®ã§ã¾ã¨ã‚ã¦ãŠãã¾ã™ã€‚\n\\(d\\)æ¬¡å…ƒç©ºé–“ã®ç«‹æ–¹ä½“\\((0,1)^d\\)ä¸­ã«åˆ†å¸ƒã™ã‚‹ç¢ºç‡å¤‰æ•°\\(X_d\\)ã‚’è€ƒãˆã¾ã™ã€‚ä¾‹ãˆã°ãƒ¢ãƒã‚¯ãƒ­ç”»åƒãªã‚“ã‹ã¯æ­£è¦åŒ–ã™ã‚Œã°ä»Šè€ƒãˆã¦ã‚‹ç¢ºç‡å¤‰æ•°ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚ä»Š\\((0, 1)\\)ä¸Šã®ä»»æ„ã®åˆ†å¸ƒ\\(F\\)ã‚’è€ƒãˆ\\(F^d\\)ã‚’ç¢ºç‡åˆ†å¸ƒã¨ã™ã‚‹\\(X_d\\)ã‹ã‚‰\\(n\\)å€‹ã®ã‚µãƒ³ãƒ—ãƒ«ãŒå¾—ã‚‰ã‚ŒãŸã¨ã—ã¾ã™ã€‚ã‚µãƒ³ãƒ—ãƒ«ã«ãŠã‘ã‚‹\\(L_k\\)ãƒãƒ«ãƒ ã®æœ€å¤§å€¤ã‚’\\(Dmax^k_d\\)ã€æœ€å°å€¤ã‚’\\(Dmin^k_d\\)ã¨ã™ã‚‹ã¨ã€\\(F\\)ã¨\\(k\\)ã®ã¿ã«ä¾å­˜ã™ã‚‹å®šæ•°\\(C_k\\)ãŒå­˜åœ¨ã—ã¦\n\\[\nC_k \\leq \\underset{d \\rightarrow \\infty}{\\lim}{\\rm E}\\left[\\frac{Dmax^k_d - Dmin^k_d}{d^{\\frac{1}{k}-\\frac{1}{2}}}\\right] \\leq (n-1)C_k\n\\]\nãŒæˆã‚Šç«‹ã¡ã¾ã™ã€‚ã“ã“ã§\\({\\rm E}[X]\\)ã¯\\(X\\)ã®æœŸå¾…å€¤ã‚’è¡¨ã—ã¾ã™ã€‚\nã¤ã¾ã‚Šãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ã™ã‚‹æ¬¡å…ƒãŒä¸ŠãŒã‚‹ã«ã¤ã‚Œã¦åŸç‚¹ã«è¿‘ã„ã‚‚ã®ã¨é ã„ã‚‚ã®ã®å·®ãŒå¤‰åŒ–ã™ã‚‹ã‚¹ãƒ”ãƒ¼ãƒ‰ã¯\\(d^{\\frac{1}{k}-\\frac{1}{2}}\\)ãã‚‰ã„ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚è¨¼æ˜ã‚’èª­ã‚ã°åˆ†ã‹ã‚Šã¾ã™ãŒã€å·®ã®æ¼¸è¿‘çš„ãªæŒ¯ã‚‹èˆã„ã‚’æ±ºã‚ã‚‹\\(d^{\\frac{1}{k}-\\frac{1}{2}}\\)ã®\\(\\frac{1}{2}\\)ã¯ä¸­å¿ƒæ¥µé™å®šç†ã‹ã‚‰å‡ºã¦ãã¾ã™ã€‚ã‚‚ã—\\(k \\geq 3\\)ã§ã‚ã‚Œã°ã“ã‚Œã¯æ¸›è¡°ã™ã‚‹ã®ã§ã€ã©ã‚“ã©ã‚“è¿‘ã„ãƒ‡ãƒ¼ã‚¿ã¨é ã„ãƒ‡ãƒ¼ã‚¿ã®é–“ã«å·®ãŒãªããªã£ã¦ãã‚‹ã¨ã„ã†ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯åŸç‚¹ã‚’ä»»æ„ã®æ³¨ç›®ã™ã‚‹ç‚¹ã«ç½®ãæ›ãˆã¦è€ƒãˆã‚Œã°ã€ä¾‹ãˆã°ã‚µãƒ³ãƒ—ãƒ«ã®è¿‘å‚ã‚’è€ƒãˆã‚‹ã¨ãã«æ¬¡å…ƒãŒé«˜ããªã‚‹ã¨é ã„ã‚‚ã®ã¨è¿‘ã„ã‚‚ã®ã®åŒºåˆ¥ãŒã©ã‚“ã©ã‚“ã¤ã‹ãªããªã£ã¦ã„ãã“ã¨ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚ä¸€æ–¹ã‚‚ã—\\(k=2\\)ã§ã‚ã‚Œã°ã“ã®å·®ã¯ä¸€å®šã«è½ã¡ç€ãã€\\(k=1\\)ã§ã‚ã‚Œã°ï¼ˆæœŸå¾…é€šã‚Šï¼Ÿï¼‰å¤§ãããªã£ã¦ãã‚Œã¾ã™ã€‚\næ¬¡å…ƒãŒé«˜ããªã‚Œã°ç«‹æ–¹ä½“ã®å¯¾è§’ç·šã®é•·ã•ã‚‚å¤§ãããªã‚‹ã®ã§ç›´æ„Ÿçš„ã«ã¯æœ€å¤§å€¤ã¨æœ€å°å€¤ã®å·®ã¯ã©ã‚“ã©ã‚“å¤§ãããªã£ã¦ã„ããã†ã§ã™ãŒã€åŒæ™‚ã«ã€ã™ã¹ã¦ã®æ¬¡å…ƒã§0ä»˜è¿‘ã®å€¤ãŒå‡ºã‚‹ç¢ºç‡ã‚„1ä»˜è¿‘ã®å€¤ãŒå‡ºã‚‹ç¢ºç‡ã¯æ¬¡å…ƒãŒé«˜ããªã‚‹ã¨ã©ã‚“ã©ã‚“å°ã•ããªã‚‹ã®ã§ã€å·®ã®æœŸå¾…å€¤ãŒã©ã†æŒ¯ã‚‹èˆã†ã‹ã¯ã“ã‚Œã‚‰ã®ç¶±å¼•ãã«ãªã‚Šãã†ãªã“ã¨ã¯ç›´æ„Ÿçš„ã«ã¯åˆ†ã‹ã‚Šã¾ã™ã€‚ã“ã®ç¶±å¼•ãã®å‹æ•—ãŒè·é›¢ã®æ¸¬ã‚Šæ–¹ã§æ±ºã¾ã‚‹ã®ã¯é¢ç™½ã„ã§ã™ã­ã€‚\nã“ã®æŒ™å‹•ã‚’å®Ÿéš›ã«ç¢ºã‹ã‚ã¦ã¿ã¾ã—ã‚‡ã†ã€‚\n\nimport Control.Monad (replicateM)\nimport System.Random.MWC\n\n\n-- | ç¢ºç‡å¤‰æ•°\ntype RVar a = GenIO -&gt; IO a\n\n\n-- | nå€‹ã®ãƒªã‚¹ãƒˆã®ç¢ºç‡å¤‰æ•°\nrandomNs :: Int -&gt; RVar a -&gt; RVar [a]\nrandomNs n x = sample n\n  where\n    sample 0 _ = pure []\n    sample n g = do\n      a &lt;- x g\n      as &lt;- sample (n-1) g\n      pure (a:as)\n\n\n-- L_kãƒãƒ«ãƒ \nlk :: Int -&gt; [Double] -&gt; Double\nlk k xs = sum (map (^k) xs) ** (1.0 / fromIntegral k)\n\n\n-- | Dmax^k_d - Dmin^k_d\ndiameter :: Int -- ç›´å¾„è¨ˆç®—ã®ãŸã‚ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’ç”Ÿæˆã™ã‚‹æ•°\n         -&gt; Int -- L_kãƒãƒ«ãƒ ã®k\n         -&gt; Int -- æ¬¡å…ƒd\n         -&gt; RVar Double\ndiameter n k d g =\n  let xs g = replicateM d (uniformR (0.0, 1.0) g)\n   in do\n     xss &lt;- randomNs n xs g\n     let ds = map (lk k) xss\n     pure $ maximum ds - minimum ds\n\n\n-- | ç¢ºç‡å¤‰æ•°ã®æœŸå¾…å€¤\nexpected :: Fractional a\n         =&gt; Int    -- æœŸå¾…å€¤ã‚’è¨ˆç®—ã™ã‚‹ã®ã«ç”¨ã„ã‚‹ã‚µãƒ³ãƒ—ãƒ«æ•°\n         -&gt; RVar a -- æœŸå¾…å€¤ã‚’æ±‚ã‚ã‚‹ç¢ºç‡å¤‰æ•°\n         -&gt; RVar a -- æœŸå¾…å€¤ã®ç¢ºç‡å¤‰æ•°\nexpected n x g = do\n  as &lt;- randomNs n x g\n  pure $ sum as / fromIntegral n\n\n\nimport Data.Traversable (forM)\nimport Graphics.Rendering.Chart.Easy\n\nds :: [Int]\nds = [1..50]\n\nwithSystemRandom $ \\gen -&gt; do\n  diff1 &lt;- forM ds $ \\d -&gt; expected 100 (diameter 100 1 d) gen\n  diff2 &lt;- forM ds $ \\d -&gt; expected 100 (diameter 100 2 d) gen\n  diff3 &lt;- forM ds $ \\d -&gt; expected 100 (diameter 100 3 d) gen\n  diff4 &lt;- forM ds $ \\d -&gt; expected 100 (diameter 100 4 d) gen\n  pure . toRenderable $ do\n      plot (line \"k = 1\" [zip ds diff1])\n      plot (line \"k = 2\" [zip ds diff2])\n      plot (line \"k = 3\" [zip ds diff3])\n      plot (line \"k = 4\" [zip ds diff4])\n\n\n\n\n\n\n\n\næ¬¡å…ƒã‚’å¢—ã‚„ã™ã«ã¤ã‚Œã¦\\(k=1\\)ã®æ™‚ã¯æœ€å°å€¤ã¨æœ€å¤§å€¤ã®å·®ãŒå¤§ãããªã£ã¦ã„ãã¾ã™ãŒã€\\(k=2\\)ã®å ´åˆã¯ä¸€å®šã«è½ã¡ç€ãã€\\(k=3,4\\)ã®å ´åˆã¯å·®ãŒã©ã‚“ã©ã‚“ãªããªã£ã¦ã„ãã€ã“ã®å‚¾å‘ã¯\\(k\\)ãŒå¤§ãã‘ã‚Œã°ã‚ˆã‚Šå¼·ã„ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚\nè«–æ–‡ã§ã¯ã‚‚ã†ä¸€ã¤é¢ç™½ã„å¼ãŒå°ã‹ã‚Œã¦ã„ã¾ã™ã€‚å…ˆç¨‹ã®ä¸ç­‰å¼ã¯æœ€å¤§å€¤ã¨æœ€å°å€¤ã®å·®ã«ã¤ã„ã¦ã§ã—ãŸãŒã€ä»Šåº¦ã¯æ¯”ã«ã¤ã„ã¦ã§ã™ã€‚\n\\[\n\\underset{d \\rightarrow \\infty}{\\lim} {\\rm E}\\left[\\sqrt{d}\\left(\\frac{Dmax^k_d}{Dmin^k_d} - 1\\right)\\right] = C\\sqrt{\\frac{1}{2k+1}}\n\\]\nãŸã ã—ã“ã®å¼ã¯\\(F\\)ãŒä¸€æ§˜åˆ†å¸ƒã§ã‚µãƒ³ãƒ—ãƒ«ãŒ2ç‚¹ã§ã‚ã‚‹æ™‚ã¨ã„ã†åˆ¶ç´„ãŒã¤ã„ã¦ã„ã¾ã™ã€‚ã“ã®å¼ãŒç¤ºå”†ã™ã‚‹ã®ã¯æœ€å¤§å€¤ã¨æœ€å°å€¤ã®æ¯”ã¯\\(\\frac{1}{\\sqrt{d}}\\)ãã‚‰ã„ã®ã‚¹ãƒ”ãƒ¼ãƒ‰ã§1ã«è¿‘ã¥ã„ã¦ã„ãã¨ã„ã†ã“ã¨ã§ã€ã“ã®æŒ™å‹•ã¯\\(k\\)ãŒ1,2ã®ã¨ãã§ã‚‚å¤‰ã‚ã‚Šã¾ã›ã‚“ã€‚"
  },
  {
    "objectID": "posts/2020-06-29/index.html",
    "href": "posts/2020-06-29/index.html",
    "title": "Haskellã®éåŒæœŸå‡¦ç†ã‚’ä½¿ã£ãŸå…¥å‡ºåŠ›ã®é‡ã­åˆã‚ã›",
    "section": "",
    "text": "ã“ã‚Œã¯ã€Haskellã«ã‚ˆã‚‹ä¸¦åˆ—ãƒ»ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã€ãƒªãƒ¢ãƒ¼ãƒˆè¼ªè¬› #10ã®ç™ºè¡¨è³‡æ–™ã§ã™ã€‚\nHaskellã®éåŒæœŸå‡¦ç†ã‚’ä½¿ã£ã¦ä¸¦è¡Œã«å…¥å‡ºåŠ›ã‚’ä¼´ã†å‡¦ç†ã‚’è¡Œã†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãæ–¹æ³•ã«ã¤ã„ã¦è¦‹ã¦ã„ãã¾ã™ã€‚ã¾ãšã€è¤‡æ•°ã®Webãƒšãƒ¼ã‚¸ã‚’ä¸¦è¡Œã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‚ˆã†ãªã‚¿ã‚¹ã‚¯ã‚’è€ƒãˆã¾ã™\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls1.hs\n\nimport Control.Concurrent\nimport Data.ByteString.Char8 as B\nimport System.Random\n\ngetURL :: String -&gt; IO ByteString\ngetURL url = do\n  delay &lt;- randomRIO (500000, 1500000) -- URLã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—ã™ã‚‹æ™‚é–“ã¨ã„ã†ã“ã¨ã«ã™ã‚‹\n  threadDelay delay\n  pure (B.pack url)\n\nexample1 :: IO ()\nexample1 = do\n  m1 &lt;- newEmptyMVar\n  m2 &lt;- newEmptyMVar\n  \n  forkIO $ do\n    r &lt;- getURL \"https://en.wikipedia.org/wiki/Shovel\"\n    putMVar m1 r\n\n  forkIO $ do\n    r &lt;- getURL \"https://en.wikipedia.org/wiki/Spade\"\n    putMVar m2 r\n\n  r1 &lt;- takeMVar m1\n  r2 &lt;- takeMVar m2\n  print (B.length r1, B.length r2)\nã¨ã„ã†å…±é€šã™ã‚‹å®Ÿè£…ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ãˆéš ã‚Œã—ã¦ã„ã‚‹ã®ã§å…±é€šåŒ–ã—ã¦ã¿ã¾ã—ã‚‡ã†\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls2.hs\n\nnewtype Async a = Async (MVar a)\n\nasync :: IO a -&gt; IO (Async a)\nasync action = do\n  var &lt;- newEmptyMVar\n  forkIO (action &gt;&gt;= putMVar var)\n  pure (Async var)\n\nwait :: Async a -&gt; IO a\nwait (Async var) = readMVar var\næ„å›³ã—ãªã„ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’é˜²ããŸã‚ã« wait ã§ã¯ takeMVar ã§ã¯ãªã readMVar ã‚’ä½¿ã£ã¦ã„ã¾ã™\nã“ã‚Œã‚’ä½¿ãˆã° example1 ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls2.hs\n\nexample2 :: IO ()\nexample2 = do\n  a1 &lt;- async (getURL \"https://en.wikipedia.org/wiki/Shovel\")\n  a2 &lt;- async (getURL \"https://en.wikipedia.org/wiki/Spade\")\n  r1 &lt;- wait a1\n  r2 &lt;- wait a2\n  print (B.length r1, B.length r2)\n\nexample2\n\n(36,35)\nãƒ¢ãƒŠãƒ‡ã‚£ãƒƒã‚¯ãªã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ã‚’ä½¿ã£ã¦æ›´ã«ç°¡æ½”ã«æ›¸ãã“ã¨ã‚‚å¯èƒ½ã§ã™\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls3.hs\n\nsites =\n  [ \"http://www.google.com\"\n  , \"http://www.bing.com\"\n  , \"http://www.yahoo.com\"\n  , \"http://www.wikipedia.com/wiki/Spade\"\n  , \"http://www.wikipedia.com/wiki/Shovel\"\n  ]\n\nexample3 :: IO ()\nexample3 = do\n  as &lt;- mapM (async . getURL) sites\n  result &lt;- mapM wait as\n  print $ fmap B.length result\n\nexample3\n\n[21,19,20,35,36]"
  },
  {
    "objectID": "posts/2020-06-29/index.html#asyncã§ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†",
    "href": "posts/2020-06-29/index.html#asyncã§ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†",
    "title": "Haskellã®éåŒæœŸå‡¦ç†ã‚’ä½¿ã£ãŸå…¥å‡ºåŠ›ã®é‡ã­åˆã‚ã›",
    "section": "Asyncã§ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†",
    "text": "Asyncã§ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†\ngetURL ã®ä¸­ã§ã‚¨ãƒ©ãƒ¼ãŒèµ·ã“ã£ãŸå ´åˆã®æŒ™å‹•ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†\n\nimport Control.Exception\n\ngetURL' :: String -&gt; IO ByteString\ngetURL' url = do\n  throwIO (ErrorCall \"oops!\")\n  pure (B.pack url)\n\nexample4 :: IO ()\nexample4 = do\n  as &lt;- mapM (async . getURL') sites\n  result &lt;- mapM wait as\n  print $ fmap B.length result\n\nexample4\n\n: \n\n\ngetURL' ã§ã¯ async ã®ä¸­ã§ putMVar ãŒå®Ÿè¡Œã•ã‚Œã‚‹å‰ã«ä¾‹å¤–ãŒæŠ•ã’ã‚‰ã‚Œã¦ã—ã¾ã†ã®ã§ wait ã«ãŠã‘ã‚‹ readMVar ãŒæ°¸é ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦ã—ã¾ã„ã¾ã™\nã“ã‚Œã‚’å®‰å…¨ãªæŒ™å‹•ã«å¤‰ãˆã‚‹ãŸã‚ã« Async å‘¨ã‚Šã®å®Ÿè£…ã‚’ä¿®æ­£ã—ã¦ã¿ã—ã¾ã—ã‚‡ã†\n\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls4.hs\n\nnewtype Async a = Async (MVar (Either SomeException a))\n\nasync :: IO a -&gt; IO (Async a)\nasync action = do\n  var &lt;- newEmptyMVar\n  forkIO (try action &gt;&gt;= putMVar var)\n  pure (Async var)\n\nwaitCatch :: Async a -&gt; IO (Either SomeException a)\nwaitCatch (Async var) = readMVar var\n\nwait :: Async a -&gt; IO a\nwait a = do\n  r &lt;- waitCatch a\n  case r of\n    Left e  -&gt; throwIO e\n    Right a -&gt; pure a\n\nasync ã¨ wait ã¯ä»¥å‰ã®ã‚‚ã®ã¨åŒã˜å‹ã§ã™ãŒã€ä¾‹å¤–ã‚’é©åˆ‡ã«ä¼æ¬ã™ã‚‹ä»•çµ„ã¿ã‚’å‚™ãˆã¦ã„ã¾ã™\n\nexample5 :: IO ()\nexample5 = do\n  as &lt;- mapM (async . getURL') sites\n  result &lt;- mapM wait as\n  print $ fmap B.length result\n\nexample5\n\n: \n\n\næœ€åˆã«éåŒæœŸå‡¦ç†ãŒä¾‹å¤–ã‚’æŠ•ã’ãŸæ™‚ç‚¹ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ãŒåœæ­¢ã—ã¦ã„ã‚‹ã®ãŒåˆ†ã‹ã‚Šã¾ã™"
  },
  {
    "objectID": "posts/2020-06-29/index.html#éåŒæœŸå‡¦ç†ã®åˆæµ",
    "href": "posts/2020-06-29/index.html#éåŒæœŸå‡¦ç†ã®åˆæµ",
    "title": "Haskellã®éåŒæœŸå‡¦ç†ã‚’ä½¿ã£ãŸå…¥å‡ºåŠ›ã®é‡ã­åˆã‚ã›",
    "section": "éåŒæœŸå‡¦ç†ã®åˆæµ",
    "text": "éåŒæœŸå‡¦ç†ã®åˆæµ\nã“ã“ã§ã¯ä¸¦è¡Œã«å®Ÿè¡Œã—ã¦ã„ã‚‹éåŒæœŸå‡¦ç†ã®ã©ã‚Œã‹ä¸€ã¤ã§ã‚‚çµæœã‚’è¿”ã—ãŸæ™‚ç‚¹ã§ä½•ã‚‰ã‹ã®å‡¦ç†ã‚’è¡Œã„ãŸã„ã‚ˆã†ãªå ´åˆã«ã¤ã„ã¦è¦‹ã¦ã„ãã¾ã™ã€‚\nä»¥ä¸‹ã®ä¾‹ã¯ä¸¦è¡Œã«è¤‡æ•°ã®Webã‚µã‚¤ãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦\n\næœ€åˆã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ãŸWebã‚µã‚¤ãƒˆã®æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹\næ®‹ã‚Šã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã™ã‚‹ã®ã‚’å¾…ã¤\n\nã¨ã„ã†æŒ™å‹•ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚\n\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls5.hs\n\nimport Control.Monad\n\nexample6 :: IO ()\nexample6 = do\n  m &lt;- newEmptyMVar\n  let download url = do\n        r &lt;- getURL url\n        putMVar m (url, r)\n\n  mapM_ (forkIO . download) sites\n  \n  (url, r) &lt;- takeMVar m\n  print $ url ++ \": \" ++ show (B.length r)\n  replicateM_ 4 (takeMVar m)\n\n-- å®Ÿè¡Œã™ã‚‹ãŸã³ã«çµæœãŒå¤‰ã‚ã‚‹\nexample6\n\n\"http://www.wikipedia.com/wiki/Shovel: 36\"\n\n\nã“ã‚Œã‚’æ˜ç¤ºçš„ã« MVar ã‚’ç”¨ã„ãšã« Async ã‚’ä½¿ã£ã¦å®Ÿè£…ã™ã‚‹äº‹ã‚’è€ƒãˆã¾ã—ã‚‡ã†ã€‚\nä»¥ä¸‹ã® waitEither ã¯2ã¤ã® Async ã‚’å—ã‘å–ã£ã¦æœ€åˆã«å®Œäº†ã—ãŸå€¤ã‚’ IO ã§è¿”ã™é–¢æ•°ã§ã™ã€‚\n\nwaitEither :: Async a -&gt; Async b -&gt; IO (Either a b)\nwaitEither a b = do\n  m &lt;- newEmptyMVar\n  forkIO $ try (fmap Left  (wait a)) &gt;&gt;= putMVar m\n  forkIO $ try (fmap Right (wait b)) &gt;&gt;= putMVar m\n  wait (Async m)\n\nã“ã®ä»•çµ„ã¯è¤‡æ•°ã® Async ã®ãƒªã‚¹ãƒˆã«ã‚‚æ‹¡å¼µã™ã‚‹ã“ã¨ãŒã§ãã¾ã™\n\nwaitAny :: [Async a] -&gt; IO a\nwaitAny as = do\n  m &lt;- newEmptyMVar\n  let forkwait a = forkIO $ try (wait a) &gt;&gt;= putMVar m\n  mapM_ forkwait as\n  wait (Async m)\n\n\n-- å‹‰å¼·ä¼šä¸­ã«é€†ã«å…¨ã¦ã®Asyncã‚’å¾…ã¤ã‚ˆã†ãªã‚³ãƒ³ãƒ“ãƒãƒ¼ã‚¿ãŒä½œã‚Œã‚‹ã‹ï¼Ÿã¨ã„ã†è³ªå•ãŒã‚ã£ãŸã®ã§å®Ÿè£…ã—ã¦ã¿ãŸä¾‹\nwaitAll :: [Async a] -&gt; IO [a]\nwaitAll = mapM wait\n\nä»¥ä¸Šã®å®Ÿè£…ã‚’ä½¿ã£ã¦ example6 ã¯æ˜ç¤ºçš„ã« MVar ã‚’ä½¿ã‚ãªã„å½¢ã§æ›¸ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\n\n-- https://github.com/simonmar/parconc-examples/blob/master/geturls6.hs\n\nexample7 :: IO ()\nexample7 = do\n  let download url = do\n        r &lt;- getURL url\n        pure (url, r)\n\n  as &lt;- mapM (async . download) sites\n  \n  (url, r) &lt;- waitAny as\n  \n  print $ url ++ \": \" ++ show (B.length r)\n  mapM_ wait as\n\nexample7\n\n\"http://www.wikipedia.com/wiki/Spade: 35\""
  },
  {
    "objectID": "posts/2024-05-12/index.html",
    "href": "posts/2024-05-12/index.html",
    "title": "Haskellã§QRåˆ†è§£ã‚’å®Ÿè£…ã™ã‚‹",
    "section": "",
    "text": "QRåˆ†è§£ã¯ä¸ãˆã‚‰ã‚ŒãŸ\\(m\\times n\\)è¡Œåˆ—\\(A\\)ã‚’\\(m\\times m\\)ã®ãƒ¦ãƒ‹ã‚¿ãƒªè¡Œåˆ—ï¼ˆå®Ÿæ•°ã®å ´åˆã€ç›´äº¤è¡Œåˆ—ï¼‰\\(Q\\)ã¨\\(m\\times n\\)ã®ä¸Šä¸‰è§’è¡Œåˆ—\\(R\\)ã®ç©ã€ã™ãªã‚ã¡\\(A=QR\\)ã¨åˆ†è§£ã™ã‚‹æ‰‹æ³•ã§ã™ã€‚ æ•°å€¤çš„ã«å®‰å®šãªè¨ˆç®—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒçŸ¥ã‚‰ã‚Œã¦ãŠã‚Šã€å›ºæœ‰å€¤ã®è¨ˆç®—ï¼ˆQRæ³•ï¼‰ã‚„ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®å®‰å®šçš„ãªè¨ˆç®—ã«ã‚‚å¿œç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãŸã“ã†ã„ã£ãŸåˆ†è§£ã¯ã‚ˆã‚ŠæŠ½è±¡çš„ãªå¯¾è±¡ã§è€ƒãˆã‚‰ã‚Œã‚‹ã“ã¨ã‚‚å¤šãã€QRåˆ†è§£ã¯åŠå˜ç´”ãƒªãƒ¼ç¾¤ã®å²©æ¾¤åˆ†è§£ã«ä¸€èˆ¬åŒ–ã•ã‚Œã‚‹ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚\nQRåˆ†è§£ã‚’å®Ÿç¾ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯Wikipediaã«ã‚‚è©³ã—ãè¼‰ã£ã¦ãŠã‚Š\n\nã‚°ãƒ©ãƒ ãƒ»ã‚·ãƒ¥ãƒŸãƒƒãƒˆã®æ­£è¦ç›´äº¤åŒ–æ³•\nãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›\nã‚®ãƒ–ãƒ³ã‚¹å›è»¢\n\nã‚’åˆ©ç”¨ã—ãŸæ‰‹æ³•ãªã©ãŒã‚ã‚Šã¾ã™ã€‚\nHaskellã§ã‚‚ä¾‹ãˆã° hmatrix ãŒ qr ã¨ã„ã†QRåˆ†è§£ã‚’è¡Œã†é–¢æ•°ã‚’æä¾›ã—ã¦ã„ãŸã‚Šã€hmatrixã‚’ä½¿ã£ãŸã‚®ãƒ–ãƒ³ã‚¹å›è»¢ã‚„ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã«ã‚ˆã‚‹QRåˆ†è§£ã®å®Ÿè£…ã‚’è§£èª¬ã—ãŸè¨˜äº‹ã‚‚ã‚ã‚Šã¾ã™ï¼ˆãŠæ°—æ¥½ Haskell ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å…¥é–€ ç·šå½¢ä»£æ•°ç·¨ï¼‰ã€‚ã—ã‹ã—æœ¬ç¨¿ã§ã¯ã‚ãˆã¦ vector-sized ã‚’ä½¿ã£ã¦è‡ªåˆ†ã§å®Ÿè£…ã—ã¦ã¿ã‚ˆã†ã¨æ€ã„ã€æ•°å€¤çš„ã«ã‚‚å®‰å®šã—ã¦ã„ã‚‹ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã‚’åˆ©ç”¨ã—ãŸå®Ÿè¡Œåˆ—ã®QRåˆ†è§£ã®å®Ÿè£…ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚\n\nå³å¸­ç·šå½¢ä»£æ•°\nã¾ãšã¯ Haskellã§å®Ÿè£…ã™ã‚‹å³å¸­ç·šå½¢ä»£æ•° ã‚’å‚è€ƒã«å®Ÿè£…ã«å¿…è¦ãªãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®å‹ã¨é–¢æ•°ã®å®šç¾©ã‚’è¡Œã„ã¾ã™ã€‚\n\nimport GHC.TypeLits\nimport Text.Printf\n\nimport Data.Vector.Sized (Vector)\nimport qualified Data.Vector.Sized as V\n\ntype Matrix m n a = Vector m (Vector n a)\n\n-- | ãƒ™ã‚¯ãƒˆãƒ«ã®ã‚¹ã‚«ãƒ©ãƒ¼å€\n(*^) :: Num a =&gt; a -&gt; Vector n a -&gt; Vector n a\n(*^) a = V.map (*a)\n\n-- | ãƒ™ã‚¯ãƒˆãƒ«ã‚’ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§å‰²ã‚‹\n(^/) :: Fractional a =&gt; Vector n a -&gt; a -&gt; Vector n a\n(^/) v a = recip a *^ v\n\n-- | å†…ç©\ndot :: Num a =&gt; Vector n a -&gt; Vector n a -&gt; a\ndot = (V.sum .) . V.zipWith (*)\n\n-- | å¤–ç©\nouter :: Num a =&gt; Vector m a -&gt; Vector n a -&gt; Matrix m n a\nouter xs ys = V.map (\\x -&gt; V.map (*x) ys) xs\n\n-- | ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰ãƒãƒ«ãƒ \nnorm2V :: Floating a =&gt; Vector n a -&gt; a\nnorm2V = sqrt . V.sum . V.map (^2)\n\n-- | ãƒªã‚¹ãƒˆã‹ã‚‰è¡Œåˆ—ã‚’ä½œæˆã™ã‚‹\nfromList :: (KnownNat m, KnownNat n) =&gt; [[a]] -&gt; Maybe (Matrix m n a)\nfromList = (=&lt;&lt;) V.fromList . mapM V.fromList\n\n-- | è¡Œåˆ—ã‚’æ•´å½¢ã—ã¦è¡¨ç¤ºã™ã‚‹\ndisplayM :: PrintfArg a\n         =&gt; Int  -- æ•°å€¤ã®è¡¨ç¤ºå¹…\n         -&gt; Int  -- æœ‰åŠ¹æ•°å­—\n         -&gt; Matrix n m a\n         -&gt; IO ()\ndisplayM w p = putStrLn . drop 1 . V.foldl (\\x v -&gt; x ++ '\\n' : V.foldl (++) \"\" (V.map (printf \"%*.*f\" w p) v)) \"\"\n\n-- | å˜ä½è¡Œåˆ—\nidentity :: (KnownNat n, Num a) =&gt; Matrix n n a\nidentity = V.generate (\\x -&gt; V.generate (\\y -&gt; if x == y then 1 else 0))\n\n-- | è¡Œåˆ—ã®ã‚¹ã‚«ãƒ©ãƒ¼å€\n(*!!) :: Num a =&gt; a -&gt; Matrix m n a -&gt; Matrix m n a\n(*!!) a = V.map (V.map (*a))\n\n-- | è¡Œåˆ—ã®è»¢ç½®\ntranspose :: KnownNat n =&gt; Matrix m n a -&gt; Matrix n m a\ntranspose = sequenceA\n\n-- | è¡Œåˆ—ç©\n(!*!) :: (KnownNat r, Num a) =&gt; Matrix m n a -&gt; Matrix n r a -&gt; Matrix m r a\na !*! b = fmap (flip fmap (transpose b) . dot) a\n\n\n\nãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›\nãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã¯ä¸ãˆã‚‰ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«\\(x\\)ã‚’å˜ä½æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«\\(v\\)ã§è¡¨ã•ã‚ŒãŸåŸå…¸ã‚’é€šã‚‹è¶…å¹³é¢ã§é¡æ˜ å¤‰æ›ã™ã‚‹å¤‰æ›ã§ã™ã€‚å¤‰æ›å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«ã¯ \\(x - 2 v \\langle v, x \\rangle\\) ã¨è¡¨ã™ã“ã¨ãŒã§ãã€ã“ã‚Œã¯è¡Œåˆ— \\(I - 2vv^{\\rm T}\\)ã‚’\\(x\\)ã«å·¦ã‹ã‚‰æ›ã‘ã¦å¤‰æ›ã—ã¦ã„ã‚‹ã¨è€ƒãˆã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã®ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã‚’ä½¿ãˆã°ã€ä¸ãˆã‚‰ã‚ŒãŸè¡Œåˆ—ã®åˆ—ãƒ™ã‚¯ãƒˆãƒ«ã‚’å·¦ã‹ã‚‰é †ç•ªã«ç¬¬næˆåˆ†ã¾ã§ã®éƒ¨åˆ†ç©ºé–“ã«å°„å½±ã—ã¦ã„ãã“ã¨ã§QRåˆ†è§£ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\nã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è©³ã—ã„è§£èª¬ã¯ä»–ã®è¨˜äº‹ã«è­²ã‚‹ã¨ã—ã¦ï¼ˆä¾‹ãˆã°Wikipediaï¼‰ã€ã•ã£ããå®Ÿè£…ã‚’è¦‹ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚ä»¥ä¸‹ householder ã¨ã—ã¦å®Ÿè£…ã™ã‚‹ã®ã¯æ·»å­—\\(i\\)ã¨ãƒ™ã‚¯ãƒˆãƒ«\\(x\\)ãŒä¸ãˆã‚‰ã‚ŒãŸæ™‚ã«ã€\\(x\\)ã®ç¬¬\\(i\\)æˆåˆ†ä»¥é™ã‚’ç¬¬\\(i\\)æˆåˆ†ã¾ã§ã®éƒ¨åˆ†ç©ºé–“ã«å°„å½±ã™ã‚‹ï¼ˆã™ãªã‚ã¡æ®‹ã‚Šã®æˆåˆ†ã‚’0ã«ã™ã‚‹ï¼‰ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã‚’è¡¨ã™è¡Œåˆ—ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã§ã™ã€‚\n\nimport Data.Maybe (fromJust)\n\nimport Data.Finite (Finite)\nimport qualified Data.Vector as V'\n\n-- | ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›\nhouseholder :: (KnownNat n, Ord a, Floating a) =&gt; Finite n -&gt; Vector n a -&gt; Matrix n n a\nhouseholder i' x =\n  let i = fromIntegral i'\n      y = V'.drop i $ V.fromSized x\n      u = y V'.// [(0, V'.head y - y `V.withSized` norm2V)]\n      padding = (V'.++) (V'.replicate i 0)\n      u_norm = u `V.withSized` norm2V\n      v = fromJust . V.toSized . padding $ V'.map (/u_norm) u\n   in if abs u_norm &lt; 1e-12 then identity else identity - 2 *!! outer v v\n\nãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®å‹ã«ã¯ã‚µã‚¤ã‚ºã«é–¢ã™ã‚‹æƒ…å ±ã‚’æŒãŸã›ã¦ã„ã¾ã™ãŒ householder ã§ã¯æœ€åˆã‹ã‚‰ãã®æƒ…å ±ã‚’æ¨ã¦ã¦ç´ ã® Data.Vector ã§å¤‰æ›ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚ç†ç”±ã¨ã—ã¦ã¯ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã‚’è¨ˆç®—ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•ï¼ˆã™ãªã‚ã¡å‹ï¼‰ã¯ç¬¬ä¸€å¼•æ•°ã§ã‚ã‚‹ i' ã®å€¤ã«ä¾å­˜ã—ã¦ãŠã‚Šã€ä»Šã®Haskellã®ä¾å­˜å‹ã ã¨ä»Šå›ã®æ§˜ãªçŠ¶æ³ã§ã¯ç°¡æ½”ã«å®Ÿè£…ã§ãã‚‹æ–¹æ³•ãŒãªã„ãŸã‚å‹ã‹ã‚‰ã‚µã‚¤ã‚ºã®æƒ…å ±ã‚’å‰Šã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚\nå®Ÿè£…ä¸­ã«å˜ä½æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«\\(v\\)ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«\\(u\\)ã‚’ãã®ãƒãƒ«ãƒ ã§å‰²ã‚‹å‡¦ç†ãŒã‚ã‚Šã¾ã™ãŒã€\\(u\\)ã®ãƒãƒ«ãƒ ãŒéå¸¸ã«å°ã•ã„å ´åˆã“ã®å‡¦ç†ã¯ä¸å®‰å®šã«ãªã‚Šã¾ã™ã€‚ã—ã‹ã—\\(u\\)ã®ãƒãƒ«ãƒ ãŒéå¸¸ã«å°ã•ã„ã¨ã„ã†ã“ã¨ã¯\\(x\\)ã¨å¤‰æ›å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«ãŒã»ã¼ç­‰ã—ã„ã¨ã„ã†çŠ¶æ³ã‚’è¡¨ã—ã¦ãŠã‚Šã€ã“ã®ã‚ˆã†ãªå ´åˆã«ã¯çµæœã¨ãªã‚‹å¤‰æ›è¡Œåˆ—ã‚’ãŸã ã®å˜ä½è¡Œåˆ—ã«ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚\n\n\nQRåˆ†è§£\nQRåˆ†è§£ã¯ä¸ãˆã‚‰ã‚ŒãŸè¡Œåˆ—ã®åˆ—ãƒ™ã‚¯ãƒˆãƒ«ã‚’å·¦ã‹ã‚‰é †ç•ªã«ãƒã‚¦ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å¤‰æ›ã—ã¦ä¸Šä¸‰è§’è¡Œåˆ—ã‚’ä½œã‚‹ã“ã¨ã«ã‚ˆã‚Šå¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\n\n{-# LANGUAGE ScopedTypeVariables #-}\n\nimport Data.Proxy\n\nimport Data.Finite (finite)\n\nqr :: forall m n a. (KnownNat m, KnownNat n, Ord a, Floating a) =&gt; Matrix m n a -&gt; (Matrix m m a, Matrix m n a)\nqr a =\n  transpose &lt;$&gt;\n    foldl (\\(q, r) i -&gt;\n      let p = householder (finite i) (V.index r (finite i))\n       in (q !*! p, r !*! p)\n    ) (identity, transpose a) [0..k-1]\n  where k = fromInteger $ min (natVal (Proxy @n)) (natVal (Proxy @m))\n\nå®Ÿè£…ä¸Šã®éƒ½åˆã§è¡Œåˆ—ã¯è¡Œãƒ™ã‚¯ãƒˆãƒ«ã®ãƒ™ã‚¯ãƒˆãƒ«ã¨ãªã£ã¦ã„ã‚‹ã®ã§ã€åˆ—ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ‰±ã†ãŸã‚ã«æœ€åˆã«è»¢ç½®ã‚’è¡Œã„\\(A^{\\rm T}\\)ã€å¾—ã‚‰ã‚ŒãŸ\\(R^{\\rm T}\\)ã‚’æœ€å¾Œã«ã‚‚ã†ä¸€åº¦è»¢ç½®ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šè¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚\\(Q\\)ã«ã¤ã„ã¦ã¯æœ¬æ¥è»¢ç½®ã—ãŸã‚‚ã®ãŒè¨ˆç®—çµæœã«ãªã‚‹ã®ã§ã‚ãˆã¦è»¢ç½®ã‚’ã—ã¦ã„ã¾ã›ã‚“ã€‚\n\n\næ•°å€¤å®Ÿé¨“\nãã‚Œã§ã¯å®Ÿè£…ã—ãŸ qr ã«ã‚ˆã£ã¦å®Ÿéš›ã«è¡Œåˆ—ã®QRåˆ†è§£ãŒã§ãã‚‹ã‹å®Ÿé¨“ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚\nã¾ãšã¯Wikipediaã«è¼‰ã£ã¦ã„ã‚‹ä¾‹ã‚’å…ƒã«å®Ÿé¨“ã—ã¦ã¿ã¾ã™ã€‚\n\n{-# LANGUAGE DataKinds #-}\n\ndo\n  let x = fromJust $ fromList\n            [ [12, -51,   4]\n            , [ 6, 167, -68]\n            , [-4,  24, -41]]\n            :: Matrix 3 3 Double\n      (q, r) = qr x\n  putStrLn \"Q = \"\n  displayM 8 3 q\n  putStrLn \"R = \"\n  displayM 8 3 r\n  putStrLn \"QR = \"\n  displayM 8 3 $ q !*! r\n  putStrLn \"Q^TQ =\"\n  displayM 8 3 $ transpose q !*! q\n\nQ = \n   0.857  -0.394  -0.331\n   0.429   0.903   0.034\n  -0.286   0.171  -0.943\nR = \n  14.000  21.000 -14.000\n   0.000 175.000 -70.000\n   0.000   0.000  35.000\nQR = \n  12.000 -51.000   4.000\n   6.000 167.000 -68.000\n  -4.000  24.000 -41.000\nQ^TQ =\n   1.000   0.000   0.000\n   0.000   1.000   0.000\n   0.000   0.000   1.000\n\n\nWolframAlphaã§ã‚‚åŒæ§˜ã®è¨ˆç®—ã‚’è¡Œã£ãŸçµæœã¨æ¯”ã¹ã¦ã¿ã¦ã‚‚å€¤ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚\næ¬¡ã«éæ­£å‰‡è¡Œåˆ—ã®å ´åˆã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚å…ˆç¨‹ã®ä¾‹ã®è¡Œãƒ™ã‚¯ãƒˆãƒ«ã¨åˆ—ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä¸€ã¤ãšã¤0ã«å¤‰ãˆãŸã‚ˆã†ãªè¡Œåˆ—ã‚’ä½¿ã£ã¦å®Ÿé¨“ã—ã¦ã¿ã¾ã™ã€‚\n\ndo\n  let x = fromJust $ fromList\n            [ [ 0,   0,   0]\n            , [ 6, 167,   0]\n            , [-4,  24,   0]]\n            :: Matrix 3 3 Double\n      (q, r) = qr x\n  putStrLn \"Q = \"\n  displayM 8 3 q\n  putStrLn \"R = \"\n  displayM 8 3 r\n  putStrLn \"QR = \"\n  displayM 8 3 $ q !*! r\n  putStrLn \"Q^TQ =\"\n  displayM 8 3 $ transpose q !*! q\n\nQ = \n  -0.000  -0.000   1.000\n   0.832   0.555   0.000\n  -0.555   0.832   0.000\nR = \n   7.211 125.640   0.000\n  -0.000 112.604   0.000\n  -0.000   0.000   0.000\nQR = \n  -0.000  -0.000   0.000\n   6.000 167.000   0.000\n  -4.000  24.000   0.000\nQ^TQ =\n   1.000   0.000  -0.000\n   0.000   1.000   0.000\n  -0.000   0.000   1.000\n\n\nå•é¡Œãªã•ãã†ã§ã™ã­ã€‚\næ¬¡ã«éæ­£æ–¹è¡Œåˆ—ã®å ´åˆã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚\n\n{-# LANGUAGE DataKinds #-}\n\ndo\n  let x = fromJust $ fromList\n            [ [12, -51]\n            , [ 6, 167]\n            , [-4,  24]]\n            :: Matrix 3 2 Double\n      (q, r) = qr x\n  putStrLn \"Q = \"\n  displayM 8 3 q\n  putStrLn \"R = \"\n  displayM 8 3 r\n  putStrLn \"QR = \"\n  displayM 8 3 $ q !*! r\n  putStrLn \"Q^TQ =\"\n  displayM 8 3 $ transpose q !*! q\n\nQ = \n   0.857  -0.394   0.331\n   0.429   0.903  -0.034\n  -0.286   0.171   0.943\nR = \n  14.000  21.000\n   0.000 175.000\n  -0.000   0.000\nQR = \n  12.000 -51.000\n   6.000 167.000\n  -4.000  24.000\nQ^TQ =\n   1.000   0.000  -0.000\n   0.000   1.000  -0.000\n  -0.000  -0.000   1.000\n\n\n\n{-# LANGUAGE DataKinds #-}\n\ndo\n  let x = fromJust $ fromList\n            [ [12, -51,   4]\n            , [ 6, 167, -68]]\n            :: Matrix 2 3 Double\n      (q, r) = qr x\n  putStrLn \"Q = \"\n  displayM 8 3 q\n  putStrLn \"R = \"\n  displayM 8 3 r\n  putStrLn \"QR = \"\n  displayM 8 3 $ q !*! r\n  putStrLn \"Q^TQ =\"\n  displayM 8 3 $ transpose q !*! q\n\nQ = \n   0.894  -0.447\n   0.447   0.894\nR = \n  13.416  29.069 -26.833\n  -0.000 172.177 -62.610\nQR = \n  12.000 -51.000   4.000\n   6.000 167.000 -68.000\nQ^TQ =\n   1.000   0.000\n   0.000   1.000\n\n\nè¡Œã‚ˆã‚Šåˆ—ãŒå¤šã„å ´åˆã§ã‚‚åˆ—ã‚ˆã‚Šè¡ŒãŒå¤šã„å ´åˆã§ã‚‚å•é¡Œãªãè¨ˆç®—ã§ãã¦ã„ã¾ã™ã€‚"
  },
  {
    "objectID": "posts/2020-07-09/index.html",
    "href": "posts/2020-07-09/index.html",
    "title": "2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å®šç¾©ã¨æ•°å€¤å®Ÿé¨“",
    "section": "",
    "text": "ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¯æ»‘ã‚‰ã‹ãªé–¢æ•°ã®ä¸€ç‚¹ã«ãŠã‘ã‚‹å€¤ã‚„å¾®åˆ†ã®å€¤ã‚’ä½¿ã£ãŸã¹ãç´šæ•°ã«ã‚ˆã£ã¦å…ƒã®é–¢æ•°ã‚’è¡¨ã™æ–¹æ³•ã§ã—ãŸã€‚\n\\[\nf(x) = f(a) + f'(a)(x - a) + \\frac{f''(a)}{2!}\\left(x-a\\right)^2 + \\frac{f'''(a)}{3!}\\left(x-a\\right)^3 + \\cdots\n\\]\nã“ã‚Œã‚’2ç‚¹ä»¥ä¸Šã«æ‹¡å¼µã—ãŸãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ãŒå­˜åœ¨ã—ã¦ã„ã¦ã€ç‰¹ã«2ç‚¹ã§ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’è¡Œã†ã‚‚ã®ã¯2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¨å‘¼ã°ã‚Œã¦ã„ã‚‹ãã†ã§ã™ã€‚\nãªã‚“ã§2ç‚¹ã§ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã—ãŸããªã‚‹ã®ã‹ã¨ã„ã†ã¨ã€æ™®é€šã®ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã ã¨1ç‚¹ã«ãŠã‘ã‚‹2néšã¾ã§ã®å¾®åˆ†å€¤ã‚’ä½¿ã‚ãªã„ã¨é”æˆã§ããªã„è¿‘ä¼¼ç²¾åº¦ã‚’2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã ã¨2ç‚¹ã«ãŠã‘ã‚‹néšã¾ã§ã®å¾®åˆ†å€¤ã§é”æˆã§ããŸã‚Šã™ã‚‹ãã†ãªã®ã§ã™ãŒï¼ˆã‚¹ã‚´ã‚¤ï¼ï¼‰[^1]ã€å€‹äººçš„ã«ã¯2ç‚¹ã§ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã™ã‚‹ã“ã¨ã§åŒºåˆ†çš„ã«å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã‚‚è¿‘ä¼¼ã§ãã‚‹ã®ãŒé¢ç™½ã„ãªã¨æ€ã„ã¾ã—ãŸã€‚\nãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¯1ç‚¹ã®å‘¨ã‚Šã«ãŠã‘ã‚‹æƒ…å ±ã—ã‹ä½¿ã‚ãªã„ã®ã§é€šå¸¸è¿‘ä¼¼ã§ãã‚‹ç¯„å›²ã¯ãã®1ç‚¹ã®è¿‘ãã¾ã§ã§ã™ã€‚ç‰¹ã«é–¢æ•°ãŒæŠ˜ã‚Œç·šã ã£ãŸã‚Šã€ReLUã®ã‚ˆã†ã«å„é ˜åŸŸã«ã‚ˆã£ã¦é•ã†é–¢æ•°ã®çµ„ã¿åˆã‚ã›ã§è¡¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯é ˜åŸŸã‚’åŒºåˆ†ã™ã‚‹ç‚¹ã‚’ã¾ãŸã„ã§è¿‘ä¼¼ã§ãã‚‹ç¯„å›²ã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ãã“ã§2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’ä½¿ãˆã°åŒºåˆ†ã™ã‚‹ç‚¹ã‚’ã¾ãŸã„ã 2ç‚¹ã®å‘¨ã‚Šã§å±•é–‹ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šãã‚Œãã‚Œã®ç‚¹ã®å‘¨ã‚Šã®æƒ…å ±ã‚’ä½¿ã£ã¦ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚ˆã‚Šã‚‚è¿‘ä¼¼ã§ãã‚‹ç¯„å›²ã‚’æ‹¡å¼µã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚ä»¥ä¸‹ã®å®šç†ã¯ã“ã®ã“ã¨ã‚’ã‚ˆã‚Šæ­£ç¢ºã«è¡¨ã—ã¦ã„ã¾ã™[^2]ã€‚\nTheorem. \\(f\\)ã‚’\\({\\mathbb R}\\)ä¸Šã®ä»¥ä¸‹ã®ã‚ˆã†ã«è¡¨ã•ã‚Œã‚‹é–¢æ•°ã¨ã™ã‚‹ã€‚\n\\[\nf(x) = \\begin{cases} p(x)\\ \\ x \\in [0, \\infty) \\\\ q(x)\\ \\ x \\in (-\\infty, 0) \\end{cases}\n\\]\nã“ã“ã§\\(p, q\\)ã¯é«˜ã€…\\(m\\)æ¬¡ã®å¤šé …å¼ã¨ã™ã‚‹ã€‚ã“ã®æ™‚ã€ã‚‚ã—\\(p(0)=q(0)\\)ã§ã‚ã‚‹ãªã‚‰ã°\\(f(x)\\)ã¯-1, 1ã«ãŠã„ã¦2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹å¯èƒ½ã§ã‚ã‚Šã€\\(p_{f,\\{-1, 1\\}(n, n)}(x)\\)ã‚’ã‚¨ãƒ«ãƒŸãƒ¼ãƒˆè£œé–“å¤šé …å¼ã ã¨ã™ã‚‹ã¨ä»¥ä¸‹ãŒæˆã‚Šç«‹ã¤ã€‚\n\\[\n\\underset{n \\rightarrow \\infty}{\\lim}p_{f,\\{-1, 1\\}(n, n)}(x)=f(x), \\forall x \\in \\left(-\\sqrt 2, \\sqrt 2\\right)\n\\]\nã¨ã“ã‚ã§ã¾ã 2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å®šç¾©ã‚’ã—ã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¯å¤šé …å¼è£œé–“ã®è€ƒãˆæ–¹ã‚’çµŒç”±ã—ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚\nï¼ˆä»¥ä¸‹ã®èª¬æ˜ã¯[^2]ã®å°å…¥éƒ¨åˆ†ã‚’å¤§ã„ã«å‚è€ƒã«ã—ã¦ã„ã¾ã™ï¼‰\nååˆ†ã«ãªã‚ã‚‰ã‹ãªå®Ÿæ•°å€¤é–¢æ•°\\(f(x)\\)ã«å¯¾ã—ã¦\\(n\\)å€‹ã®ç‚¹\\(X = \\{x_0,\\dots,x_n\\}\\)ã¨ãã‚Œãã‚Œã®ç‚¹ã«å¯¾å¿œã™ã‚‹è‡ªç„¶æ•°\\(k_i(0\\leq i\\leq n)\\)ãŒä¸ãˆã‚‰ã‚ŒãŸæ™‚ã€é«˜ã€…\\(m(=k_0+\\cdots+k_n-1)\\)æ¬¡ã®å¤šé …å¼\\(p_{f,X(k_0,\\dots,k_n)}(x)\\)ãŒå­˜åœ¨ã—ã¦\n\\[\np^{(j)}_{f,X(k_0,\\dots,k_n)}(x_i) = f^{(j)}(x_i), 0\\leq j \\leq k_i-1, 0 \\leq i \\leq n\n\\]\nã‚’æº€ãŸã™æ™‚ã€\\(p_{f,X(k_0,\\dots,k_n)}(x)\\)ã‚’\\(f(x)\\)ã®ã‚¨ãƒ«ãƒŸãƒ¼ãƒˆè£œé–“å¤šé …å¼ã¨å‘¼ã³ã¾ã™ã€‚\nã‚‚ã—\\(f(x)\\)ãŒä¸€ç‚¹\\(x_0\\)ã®å‘¨ã‚Šã§ç„¡é™å›å¾®åˆ†å¯èƒ½ã§ã‚ã‚Šã€ã‚ã‚‹æ­£ã®å®Ÿæ•°\\(\\rho\\)ãŒå­˜åœ¨ã—ã¦\n\\[\n\\underset{n \\rightarrow \\infty}{\\lim} p_{f,X(n)}(x) = f(x), \\forall x \\in (x_0-\\rho, x_0+\\rho)\n\\]\nã¨ãªã‚‹ãªã‚‰ã°\\(f(x)\\)ã¯åŒã˜ç¯„å›²ã§ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹å¯èƒ½ã§ã‚ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚\nã“ã®äº‹å®Ÿã‚’ç™ºå±•ã•ã›ã¦\\(n\\)ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¾ã™ã€‚\n\\(f\\)ã‚’ã‚ã‚‹åŒºé–“\\(I\\)ã§å®šç¾©ã•ã‚ŒãŸå®Ÿæ•°å€¤é–¢æ•°ã¨ã—ã€\\(I\\)ã«å«ã¾ã‚Œã‚‹\\(n\\)å€‹ã®ç‚¹\\(X=\\{x_0,\\dots x_{n-1}\\}\\)ã§\\(f\\)ãŒç„¡é™å›å¾®åˆ†å¯èƒ½ã§ã‚ã£ãŸã¨ã™ã‚‹ã€‚ã‚‚ã—\n\\[\n\\underset{m \\rightarrow \\infty}{\\lim} p_{f,X(m,\\dots,m)}(x) = f(x), \\forall x \\in I\n\\]\nãŒæˆã‚Šç«‹ã¤ãªã‚‰ã°\\(f\\)ã¯\\(I\\)ã«ãŠã„ã¦\\(n\\)ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹å¯èƒ½ã§ã‚ã‚‹ã¨ã„ã†ã€‚\n\\(n\\)ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å…·ä½“çš„ãªå½¢ã¯ã€ã‚¨ãƒ«ãƒŸãƒ¼ãƒˆè£œé–“å¤šé …å¼ã®ä¸€èˆ¬å…¬å¼ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹ã®ã§[^3]ãã¡ã‚‰ã‹ã‚‰è¨ˆç®—å¯èƒ½ã§ã—ã‚‡ã†ã€‚ç‰¹ã«2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å ´åˆã®ç´šæ•°ã®è¨ˆç®—å¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã§ãã‚‹ã¨Twitterã§æ•™ãˆã¦ã‚‚ã‚‰ã„ã¾ã—ãŸ[^4]ã€‚ï¼ˆãã‚‚ãã‚‚2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’çŸ¥ã£ãŸãã£ã‹ã‘ã‚‚ã€ã“ã®notebookã‚’æ›¸ã“ã†ã¨æ€ã£ãŸã®ã‚‚å³¶ç”°ã•ã‚“ã®Tweetã«è§¦ç™ºã•ã‚Œã¦ã§ã—ãŸã€‚æ„Ÿè¬ğŸ™ï¼‰"
  },
  {
    "objectID": "posts/2020-07-09/index.html#æ•°å€¤å®Ÿé¨“",
    "href": "posts/2020-07-09/index.html#æ•°å€¤å®Ÿé¨“",
    "title": "2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å®šç¾©ã¨æ•°å€¤å®Ÿé¨“",
    "section": "æ•°å€¤å®Ÿé¨“",
    "text": "æ•°å€¤å®Ÿé¨“\næ¯”è¼ƒã®ãŸã‚ã«ã¾ãšã¯é€šå¸¸ã®ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã™\n\n{-# LANGUAGE RankNTypes #-}\n\nimport Data.Number.Symbolic\n\nimport Numeric.AD\nimport Numeric.AD.Mode.Tower\n\n\n-- éšä¹—\nfact :: Int -&gt; Int\nfact n = product [1..n]\n\n\n-- ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹\ntaylorSeries :: Fractional a\n             =&gt; Int                                          -- ã“ã®æ¬¡æ•°ä»¥ä¸‹ã®ç´šæ•°ã¾ã§å±•é–‹ã™ã‚‹\n             -&gt; (forall s. AD s (Tower a) -&gt; AD s (Tower a)) -- ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã™ã‚‹é–¢æ•°\n             -&gt; a                                            -- å±•é–‹ã™ã‚‹ç‚¹\n             -&gt; (a -&gt; a)                                     -- å±•é–‹å¾Œã®ç´šæ•°\ntaylorSeries n f a x = sum $ take n $ coefficients |*| polynomials\n  where\n  coefficients = diffs f a |/| factorials      -- f(a)/0!, f'(a)/1!, f''(a)/2!, f'''(a)/3!, ...\n  factorials = map (fromIntegral . fact) [0..] -- 0!, 1!, 2!, 3!, ...\n  polynomials = ((x - a)^) &lt;$&gt; [0..]           -- 1, x-a, (x-a)^2, (x-a)^3, ...\n  (|/|) = zipWith (/)\n  (|*|) = zipWith (*)\n\n\ntaylorSeries 4 exp 0 (var \"x\")\n\n1.0+x+0.5*x*x+0.16666666666666666*x*x*x\n\n\n4æ¬¡ã¾ã§ã®æŒ‡æ•°é–¢æ•°ã®ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’ã¡ã‚ƒã‚“ã¨è¨ˆç®—ã§ãã¦ã„ã¾ã™ã­\n\\[\n1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!}\n\\]\næ¬¡ã¯2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†\n\n-- 2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹\ntwoPointTaylorSeries :: Fractional a\n                     =&gt; Int                                          -- ã“ã®æ¬¡æ•°ä»¥ä¸‹ã®ç´šæ•°ã¾ã§å±•é–‹ã™ã‚‹\n                     -&gt; (forall s. AD s (Tower a) -&gt; AD s (Tower a)) -- ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã™ã‚‹é–¢æ•°\n                     -&gt; a                                            -- å±•é–‹ã™ã‚‹ç‚¹1\n                     -&gt; a                                            -- å±•é–‹ã™ã‚‹ç‚¹2\n                     -&gt; (a -&gt; a)                                     -- å±•é–‹å¾Œã®ç´šæ•°\ntwoPointTaylorSeries n f a b x = seriesA + seriesB\n  where\n  seriesA = (x - a) ^ n * sum (take n $ coefB |*| polyB)\n  seriesB = (x - b) ^ n * sum (take n $ coefA |*| polyA)\n  fa x = f x / (x - auto b)^n        -- A(x)\n  fb x = f x / (x - auto a)^n        -- B(x)\n  coefA = diffs fa a |/| factorials  -- A(a)/0!, A'(a)/1!, A''(a)/2!, A'''(a)/3!, ...\n  coefB = diffs fb b |/| factorials  -- B(b)/0!, B'(b)/1!, B''(b)/2!, B'''(b)/3!, ...\n  polyA = ((x - a)^) &lt;$&gt; [0..]       -- 1, x-a, (x-a)^2, (x-a)^3, ...\n  polyB = ((x - b)^) &lt;$&gt; [0..]       -- 1, x-b, (x-b)^2, (x-b)^3, ...\n  factorials = map (fromIntegral . fact) [0..] -- 0!, 1!, 2!, 3!, ...\n  (|/|) = zipWith (/)\n  (|*|) = zipWith (*)\n\n\ntwoPointTaylorSeries 2 id (-1) 1 (var \"x\") -- id â‰¡ f(x) = x\n\n0.25*(1.0+x)*(1.0+x)+(-0.25)*(-1.0+x)*(-1.0+x)\n\n\nå¼ãŒè¤‡é›‘ã«ãªã‚‹ã®ã§\\(f(x)=x\\)ã¨ã„ã†å˜ç´”ãªé–¢æ•°ã‚’å±•é–‹ã—ã¦ç¢ºã‹ã‚ã¦ã¿ã¾ã—ãŸã€‚å¼ã‚’æ•´ç†ã™ã‚‹ã¨ã¡ã‚ƒã‚“ã¨æ­£ã—ã„ç­”ãˆã«ãªã£ã¦ã‚‹ã®ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚\nãã‚Œã§ã¯å®Ÿéš›ã«é–¢æ•°ã‚’è¿‘ä¼¼ã—ã¦ã¿ã¾ã—ã‚‡ã†\nã¾ãšã¯\n\\[\n\\frac{1}{1+x^2}\n\\]\nã¨ã„ã†é–¢æ•°ã‚’å±•é–‹ã—ã¦ã¿ã¾ã—ã‚‡ã†\n\nimport Graphics.Rendering.Chart.Easy\n\ncauchy :: Floating a =&gt; a -&gt; a\ncauchy x = 1 / (1 + x^2)\n\ndomain :: [Double]\ndomain = map (\\n -&gt; fromIntegral n / 100) [-100..100]\n\ntoRenderable $ do\n    plot (line \"cauchy\"    [flip map domain $ \\x -&gt; (x, cauchy x)])\n    plot (line \"one point\" [flip map domain $ \\x -&gt; (x, taylorSeries 5 cauchy 0 x)])\n    plot (line \"two point\" [flip map domain $ \\x -&gt; (x, twoPointTaylorSeries 5 cauchy (-1) 1 x)])\n\n\n\n\n\n\n\n\né’ç·šãŒå…ƒã®é–¢æ•°ã€ç·‘ç·šãŒ\\(0\\)å‘¨ã‚Šã§ã®5æ¬¡ã¾ã§ã®ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã€èµ¤ç·šãŒ\\(-1, 1\\)å‘¨ã‚Šã§ã®5æ¬¡ã¾ã§ã®2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã§ã™ã€‚åŒã˜æ¬¡æ•°ã¾ã§ã®å±•é–‹ã§ã™ãŒ2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®ã»ã†ãŒã‚ˆã‚Šé«˜ã„ç²¾åº¦ã§è¿‘ä¼¼ã§ãã¦ã„ã‚‹ã®ãŒåˆ†ã‹ã‚Šã¾ã™\næ¬¡ã«åŒºåˆ†çš„ã«å®šç¾©ã•ã‚ŒãŸé–¢æ•°ã§ã‚ã‚‹ReLUã‚’å±•é–‹ã—ã¦ã¿ã¾ã—ã‚‡ã†\n\nrelu :: (Ord a, Floating a) =&gt; a -&gt; a\nrelu = max 0\n\ntoRenderable $ do\n    plot (line \"ReLU\"      [flip map domain $ \\x -&gt; (x, relu x)])\n    plot (line \"one point\" [flip map domain $ \\x -&gt; (x, taylorSeries 5 relu 1 x)])\n    plot (line \"two point\" [flip map domain $ \\x -&gt; (x, twoPointTaylorSeries 5 relu (-1) 1 x)])\n\n\n\n\n\n\n\n\nãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¯\\(1\\)ã®å‘¨ã‚Šã§å±•é–‹ã—ã¦ã„ã¾ã™ãŒã‚„ã¯ã‚Š0ä»¥ä¸‹ã§é–¢æ•°ãŒå¤‰ã‚ã£ã¦ã„ã‚‹ã“ã¨ã«ã¯å¯¾å¿œã§ãã¦ã„ã¾ã›ã‚“ã€‚ä¸€æ–¹ã§2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã¯\\(1\\)ã®å‘¨ã‚Šã«åŠ ãˆã¦\\(-1\\)ã®å‘¨ã‚Šã®æƒ…å ±ã‚‚ã¤ã‹ãˆã¦ã„ã‚‹ã®ã§ReLUã®å½¢ã‚’ã‚ˆã‚Šæ­£ç¢ºã«è¿‘ä¼¼ã§ãã¦ã„ã‚‹ã®ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚"
  },
  {
    "objectID": "posts/2020-07-09/index.html#å‚è€ƒæ–‡çŒ®",
    "href": "posts/2020-07-09/index.html#å‚è€ƒæ–‡çŒ®",
    "title": "2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å®šç¾©ã¨æ•°å€¤å®Ÿé¨“",
    "section": "å‚è€ƒæ–‡çŒ®",
    "text": "å‚è€ƒæ–‡çŒ®\n\n[1] Estes, R. H., and E. R. Lancaster. â€œTwo-point Taylor series expansions.â€ (1966).\n[2] Kitahara, Kazuaki, Taizo Chiyonobu, and Hirokazu Tsukamoto. â€œA note on two point Taylor expansion.â€ International Journal of Pure and Applied Mathematics 75.3 (2012): 327-338.\n[3] éˆ´æœ¨ å®Ÿ, â€œã‚¨ãƒ«ãƒŸãƒ¼ãƒˆè£œé–“ã®ä¸€èˆ¬å…¬å¼ï¼ˆGeneralized Hermite interpolationï¼‰â€ http://totoha.web.fc2.com/Hermite_interpolation.pdf\n[4] https://twitter.com/KS_Mathematics/status/1279807348391854080"
  },
  {
    "objectID": "posts/2024-03-23/index.html",
    "href": "posts/2024-03-23/index.html",
    "title": "Haskellã§å®Ÿè£…ã™ã‚‹k-meansæ³•ã¨k-means++æ³•",
    "section": "",
    "text": "k-meanså•é¡Œã¯ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã«é–¢ã™ã‚‹å•é¡Œã§ã€ãƒ‡ãƒ¼ã‚¿ã®é›†åˆã‚’\\(X\\)ã€ã‚¯ãƒ©ã‚¹ã‚¿æ•°ã‚’\\(k\\)ã¨ã—ãŸæ™‚ã«ã€\\(X\\)ã®åˆ†å‰²\\(S = \\{S_1, S_2, \\dots, S_k\\}\\) ã®ä¸­ã§ä»¥ä¸‹ã®ã‚³ã‚¹ãƒˆé–¢æ•°\n\\[\n\\underset{S}{\\arg\\min} \\sum_{i=1}^k\\sum_{x\\in S_i}\\|x-\\mu_i\\|^2\n\\]\nã‚’æœ€å°ã«ã™ã‚‹ã‚‚ã®ã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ãŒç›®çš„ã§ã™ã€‚\nã“ã“ã§ \\(\\mu_i\\) ã¯ã‚¯ãƒ©ã‚¹ã‚¿ã®ä¸­å¿ƒã§\n\\[\n\\mu_i = \\frac{1}{|S_i|}\\sum_{x\\in S_i}x\n\\]\nã¨å¹³å‡å€¤ã§è¨ˆç®—ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚\n\nk-meansæ³•\nã“ã®å•é¡Œã¯NPå›°é›£ã§ã‚ã‚‹ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ãŒã€k-meansæ³•ï¼ˆLloydã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰ã¨å‘¼ã°ã‚Œã‚‹å±€æ‰€è§£ã‚’é«˜é€Ÿã«ä¸ãˆã‚‹æœ‰åãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚\n\nã‚¯ãƒ©ã‚¹ã‚¿ã®ä¸­å¿ƒã¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ç‚¹ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«kå€‹ã‚’é¸ã¶\nå„ãƒ‡ãƒ¼ã‚¿ç‚¹ã‚’ä¸­å¿ƒãŒæœ€ã‚‚è¿‘ã„ã‚¯ãƒ©ã‚¹ã‚¿ã«åˆ†é¡ã™ã‚‹\nå„ã‚¯ãƒ©ã‚¹ã‚¿ã«å±ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ”¹ã‚ã¦ä¸­å¿ƒã‚’è¨ˆç®—ã™ã‚‹\nåæŸã™ã‚‹ã¾ã§2,3ã‚’ç¹°ã‚Šè¿”ã™\n\nã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã¯å®Ÿéš›ã«è¦–è¦šçš„ã«è¦‹ã¦ã¿ã‚‹ã®ãŒåˆ†ã‹ã‚Šã‚„ã™ã„ã§ã—ã‚‡ã†ã€‚ä»¥ä¸‹ã®ã‚µã‚¤ãƒˆãŒk-meansæ³•ã‚’å¯è¦–åŒ–ã—ã¦ãã‚Œã¦ã„ã¦ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«è©¦ã™ã“ã¨ãŒã§ãã‚‹ã®ã§ã‚ªã‚¹ã‚¹ãƒ¡ã§ã™ã€‚\n\nK-means æ³•ã‚’ D3.js ã§ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ã¿ãŸ\n\nHaskellã«ã‚‚k-meansæ³•ã‚’å®Ÿè£…ã—ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã‚ã‚Šã¾ã™ã€‚\n\nkmeans\nkmeans-vector\nclustering\n\nã§ã™ãŒä»Šå›ã¯è‡ªåˆ†ã§å®Ÿè£…ã—ã¾ã™ã€‚\n\n{-# LANGUAGE BlockArguments, DataKinds #-} \n\nimport GHC.TypeLits\n\nimport qualified Data.Vector.Sized as V\n\n\n-- | ãƒœãƒ­ãƒã‚¤åˆ†å‰²\nvoronoiDecompose :: (KnownNat (n+1), Ord b)\n                 =&gt; (a -&gt; a -&gt; b)       -- è·é›¢é–¢æ•°\n                 -&gt; [a]                 -- ãƒ‡ãƒ¼ã‚¿ç‚¹\n                 -&gt; V.Vector (n+1) a    -- ä¸­å¿ƒç‚¹\n                 -&gt; V.Vector (n+1) [a]  -- ãƒœãƒ­ãƒã‚¤åˆ†å‰²\nvoronoiDecompose distance ds cs =\n  V.accum (flip (:)) (V.replicate []) $\n    map (\\d -&gt; (V.minIndex $ V.map (distance d) cs, d)) ds\n\n\n-- | k-meansæ³•\nkMeans :: (KnownNat (n+1), Eq a, Ord b)\n       =&gt; (a -&gt; a -&gt; b)     -- è·é›¢é–¢æ•°\n       -&gt; ([a] -&gt; a)        -- é›†ç´„é–¢æ•°\n       -&gt; [a]               -- ãƒ‡ãƒ¼ã‚¿ç‚¹\n       -&gt; V.Vector (n+1) a  -- ä¸­å¿ƒç‚¹\n       -&gt; V.Vector (n+1) a  -- ä¸­å¿ƒç‚¹\nkMeans distance aggregate ds cs =\n  let cs' = V.map aggregate $ voronoiDecompose distance ds cs\n   in if cs == cs' then cs' else kMeans distance aggregate ds cs'\n\nvoronoiDecompose ã¯ä¸ãˆã‚‰ã‚ŒãŸä¸­å¿ƒç‚¹ã«å¾“ã£ã¦ãƒ‡ãƒ¼ã‚¿ç‚¹ã‚’ãƒœãƒ­ãƒã‚¤é ˜åŸŸã§åˆ†é¡ã™ã‚‹é–¢æ•°ã§ã™ã€‚ãƒ‡ãƒ¼ã‚¿ç‚¹ã¯ãƒªã‚¹ãƒˆã¨ã—ã¦æ‰±ã£ã¦ã„ã¾ã™ãŒã€ä¸­å¿ƒç‚¹ã¯ãƒ©ãƒ³ãƒ€ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã„ã®ã§ Vector ã‚’ä½¿ã£ã¦ \\(O(1)\\) ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ç‚¹ã®å‹ã¯å‹å¤‰æ•°ã§æŠ½è±¡åŒ–ã—ã¦ãŠã‚Šã€å¿…è¦ã«ãªã‚‹è·é›¢é–¢æ•°ã¯å¾Œã‹ã‚‰ä¸ãˆã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚\nkMeans ã¯k-meansæ³•ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã§ã™ã€‚ãƒ‡ãƒ¼ã‚¿ç‚¹ã‚’ãƒœãƒ­ãƒã‚¤åˆ†å‰²ã—ãŸçµæœã‚’é›†ç´„ã—ã¦è¨ˆç®—ã—ãŸæ–°ã—ã„ä¸­å¿ƒç‚¹ãŒã‚‚ã¨ã®ä¸­å¿ƒç‚¹ã¨ä¸€è‡´ã™ã‚‹ã¾ã§è¨ˆç®—ã‚’ç¹°ã‚Šè¿”ã—ã¾ã™ã€‚\n\n\nk-means++æ³•\nkMeans ã¯ä¸­å¿ƒç‚¹ã‚’æ›´æ–°ã—ã¦ã„ãé–¢æ•°ã¨ã—ã¦å®Ÿè£…ã—ã¦ã„ã¾ã™ãŒãã‚‚ãã‚‚ã®ä¸­å¿ƒç‚¹ã¯ã©ã®ã‚ˆã†ã«ç”¨æ„ã™ã‚Œã°è‰¯ã„ã§ã—ã‚‡ã†ã‹ã€‚ã‚‚ã¡ã‚ã‚“ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ‡ãƒ¼ã‚¿ç‚¹ã‚’å–ã£ã¦ãã¦ã‚‚è‰¯ã„ã®ã§ã™ãŒã€k-means++æ³•ã¨å‘¼ã°ã‚Œã‚‹åŠ¹ç‡ã®è‰¯ã„ä¸­å¿ƒç‚¹ã®ä¸ãˆæ–¹ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚k-means++æ³•ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã™ã€‚\n\nãƒ‡ãƒ¼ã‚¿ç‚¹ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤ç›®ã®ä¸­å¿ƒç‚¹ã‚’é¸ã¶\nãã‚Œãã‚Œã®ãƒ‡ãƒ¼ã‚¿ç‚¹\\(x\\)ã«å¯¾ã—ã¦ã€æœ€ã‚‚è¿‘ã„ä¸­å¿ƒç‚¹ã‹ã‚‰ã®è·é›¢\\(D(x)\\)ã‚’è¨ˆç®—ã™ã‚‹\nãƒ‡ãƒ¼ã‚¿ç‚¹\\(x\\)ã«ã¤ãé‡ã¿\\(\\frac{D^2(x)}{\\sum_{x\\in X}D^2(x)}\\)ã‚’è€ƒæ…®ã—ã¦æ–°ã—ã„ä¸­å¿ƒç‚¹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶\né¸ã°ã‚ŒãŸä¸­å¿ƒç‚¹ã®æ•°ãŒäºˆã‚ä¸ãˆã‚‰ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿æ•°\\(k\\)ã«åˆ°é”ã™ã‚‹ã¾ã§2,3ã‚’ç¹°ã‚Šè¿”ã™\n\næ„Ÿè¦šçš„ã«ã¯ä»Šã‚ã‚‹ä¸­å¿ƒç‚¹ã‚ˆã‚Šé ãã«ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ç‚¹ãŒé¸ã°ã‚Œã‚„ã™ããªã‚‹ã‚ˆã†ã«æ–°ã—ã„ä¸­å¿ƒç‚¹ã‚’é¸ã¶ã‚ˆã†ãªå½¢ã«ãªã£ã¦ã„ã¾ã™ã€‚ãã‚Œãªã‚‰å˜ç´”ã«\\(D(x)\\)ã«æ¯”ä¾‹ã—ãŸé‡ã¿ã§ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦ã‚‚è‰¯ã•ãã†ãªã‚‚ã®ã§ã™ãŒã€ã“ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã£ã¦é¸ã°ã‚ŒãŸä¸­å¿ƒç‚¹ã«ã‚ˆã‚Šè©•ä¾¡ã—ãŸk-meanså•é¡Œã®ã‚³ã‚¹ãƒˆé–¢æ•°ã®å€¤ã‚’\\(\\phi\\)ã¨ã™ã‚‹ã¨ã€ã‚³ã‚¹ãƒˆé–¢æ•°ã®æœ€å°å€¤\\(\\phi_{\\rm OPT}\\)ã«å¯¾ã—ã¦\n\\[\n{\\rm E}[\\phi] \\leq 8(\\log k+2)\\phi_{\\rm OPT}\n\\]\nã‚’æº€ãŸã™ã“ã¨ãŒè¨¼æ˜ã§ãã¾ã™ã€‚ã“ã®è¨¼æ˜ã«ã¯ã‚³ãƒ¼ã‚·ãƒ¼ãƒ»ã‚·ãƒ¥ãƒ¯ãƒ«ãƒ„ã®ä¸ç­‰å¼ãŒä½¿ã‚ã‚Œã¦ã„ã¦äºŒä¹—ã®å½¢ã§ã‚ã‚‹ã“ã¨ãŒæœ¬è³ªçš„ãªå½¹å‰²ã‚’æœãŸã—ã¦ã„ã‚‹ã®ã§ã™ï¼ˆã‚‚ã†å°‘ã—è’ã„è©•ä¾¡ã«ã¯ãªã‚Šã¾ã™ãŒå˜ç´”ã«\\(l^p\\)è·é›¢ã‚’ç”¨ã„ãŸå ´åˆã®ä¸ç­‰å¼ã‚‚è«–æ–‡ã«ã¯è¼‰ã£ã¦ã„ã¾ã™ï¼‰ã€‚ã“ã®ã‚ˆã†ã«k-means++æ³•ã¯åˆæœŸã®ä¸­å¿ƒç‚¹ã‚’æ±ºã‚ãŸæ™‚ç‚¹ã§æœŸå¾…å€¤ã«ãŠã‘ã‚‹ç†è«–çš„ãªç²¾åº¦è©•ä¾¡ãŒå¾—ã‚‰ã‚Œã¦ã„ã¾ã™ãŒã€æ›´ã«ãã®å¾Œk-meansæ³•ã‚’ç”¨ã„ã¦ã‚³ã‚¹ãƒˆé–¢æ•°ã‚’å˜èª¿æ¸›å°‘ã•ã›ã‚‹ã“ã¨ã«ã‚ˆã‚Šè‰¯ã„ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã®çµæœãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã®ã§ã™ã€‚\nãã‚Œã§ã¯k-means++æ³•ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚\n\nimport Data.Proxy (Proxy(..))\n\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Sized.Internal as VGSI\nimport Data.Random (randomElement, RVar)\nimport Data.Random.Distribution.Categorical (weightedCategorical)\n\n\n-- ref. https://github.com/expipiplus1/vector-sized/issues/123\nunfoldrM :: forall m n a b. (Monad m, KnownNat n)\n         =&gt; (b -&gt; m (a, b)) -&gt; b -&gt; m (V.Vector n a)\nunfoldrM f z = VGSI.Vector &lt;$&gt; VG.unfoldrExactNM i f z\n  where i = fromIntegral (natVal (Proxy :: Proxy n))\n\n\n-- | k-means++æ³•\nkMeansPlusPlus :: KnownNat n\n               =&gt; (a -&gt; a -&gt; Double)  -- è·é›¢é–¢æ•°\n               -&gt; [a]                 -- ãƒ‡ãƒ¼ã‚¿ç‚¹\n               -&gt; RVar (V.Vector n a) -- ä¸­å¿ƒç‚¹\nkMeansPlusPlus distance ds = unfoldrM f []\n  where\n  f [] = do\n    c &lt;- randomElement ds\n    pure (c, [c])\n  f cs = do\n    let ws = map (\\d -&gt; minimum $ map (\\c -&gt; distance c d ^2) cs) ds\n    c &lt;- weightedCategorical (zip ws ds)\n    pure (c, c:cs)\n\nk-means++æ³•ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã«unfoldrMã¨ã„ã†ä¾¿åˆ©é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚å®Ÿã¯vectorãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã“ã®ã‚ˆã†ãªé–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§ã™ãŒvector-sizedã«ã¯ç„¡ã„ã®ã§è‡ªå‰ã§å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼ˆå®Ÿè£…ã—ã¦æ¬²ã—ã„ã¨ã„ã†issueã¯ã‚ã‚Šã¾ã™ï¼‰ã€‚\nunfoldrMã‚’ä½¿ãˆã°k-means++æ³•ã¯ç´ ç›´ã«å ´åˆåˆ†ã‘ã—ã¦å®Ÿè£…ã™ã‚‹ã ã‘ã§ã™ã€‚k-means++æ³•ã¯ãƒ©ãƒ³ãƒ€ãƒ ãªé¸æŠã‚’ä¼´ã†ã®ã§ä½•ã‚‰ã‹ã®ãƒ¢ãƒŠãƒ‰ã«åŒ…ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚IOã«ã—ã¦ã—ã¾ã£ã¦ã‚‚è‰¯ã„ã®ã§ã™ãŒç¢ºç‡åˆ†å¸ƒã‚‚ã¾ãŸãã‚Œè‡ªä½“ãŒãƒ¢ãƒŠãƒ‰ã«ãªã‚‹ã®ã§ã€ã§ãã‚‹ã ã‘æŠ½è±¡çš„ãªå‹ã«ç•™ã‚ã‚‹å½¢ã§å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚ç¢ºç‡åˆ†å¸ƒï¼ˆç¢ºç‡å¤‰æ•°ï¼‰ã®å‹ã¨ã—ã¦ã€ã“ã“ã§ã¯ random-fuã®RVarã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚\n\n\nå®Ÿé¨“\nãã‚Œã§ã¯å®Ÿè£…ã—ãŸk-meansæ³•ã€k-means++æ³•ã‚’ä½¿ã£ã¦å®Ÿéš›ã«ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã¾ãšã¯ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã®å¯¾è±¡ã¨ãªã‚‹å¹³é¢ä¸Šã®ç‚¹ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚\n\nimport Data.List (foldl')\nimport Data.Maybe (fromJust)\n\n\n-- | å¹³é¢ä¸Šã®ç‚¹\ntype Point = V.Vector 2 Double\n\n\n-- | x, y åº§æ¨™ã‹ã‚‰ç‚¹ã‚’æ§‹ç¯‰ã™ã‚‹\nmkPoint :: Double -&gt; Double -&gt; Point\nmkPoint a b = fromJust $ V.fromList [a, b]\n\n\n-- | è·é›¢é–¢æ•°\ndistance :: Point -&gt; Point -&gt; Double\ndistance v1 v2 = sqrt . V.sum . V.map (^2) $ V.zipWith (-) v1 v2\n\n\n-- | å¹³å‡å€¤é–¢æ•°\naverage :: [Point] -&gt; Point\naverage ps =\n  let n = fromIntegral $ length ps\n   in V.map (/n) $ foldl' (V.zipWith (+)) (V.replicate 0) ps\n\næœ€å¾Œã«ã“ã‚Œã‚‰ã®ç‚¹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã‚¯ãƒ©ã‚¹ã‚¿ã®æ•°ã¯å‹ã«ç¾ã‚Œã‚‹ã®ã§å‹æ³¨é‡ˆã§ä¸ãˆã¾ã™ã€‚\n\nimport Control.Monad (replicateM)\nimport Data.Traversable (forM)\n\nimport Data.Random (normal, sampleFrom)\nimport Graphics.Rendering.Chart.Easy\nimport System.Random.Stateful (newIOGenM, mkStdGen)\n\n\nsamples :: RVar [Point]\nsamples = concat &lt;$&gt; forM clusters \\(m, s) -&gt;\n  replicateM nEachSamples $ mkPoint &lt;$&gt; normal m s &lt;*&gt; normal m s\n  where\n  nEachSamples = 100  \n  clusters = [(-2, 1), (4, 2)]\n\n\ndo\n  gen &lt;- newIOGenM (mkStdGen 42)\n  ds &lt;- sampleFrom gen samples\n  cs &lt;- sampleFrom gen $\n    kMeansPlusPlus distance ds :: IO (V.Vector 2 Point)  -- k-means++æ³•\n  let cs' = kMeans distance average ds cs  -- k-meansæ³•\n      voronoi = voronoiDecompose distance ds cs'\n      toTuple v = (V.index v 0, V.index v 1)\n  pure $ toRenderable $ do\n    plot (points \"Group 1\" . map toTuple $ V.index voronoi 0)\n    plot (points \"Group 2\" . map toTuple $ V.index voronoi 1)"
  },
  {
    "objectID": "posts/2020-04-12/index.html",
    "href": "posts/2020-04-12/index.html",
    "title": "GHCi ã® :sprint ãŒä¾¿åˆ©",
    "section": "",
    "text": "ã“ã‚Œã¯ã€Haskellã«ã‚ˆã‚‹ä¸¦åˆ—ãƒ»ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã€ãƒªãƒ¢ãƒ¼ãƒˆè¼ªè¬› #1ã§å­¦ã‚“ã ã“ã¨ã®ãƒ¡ãƒ¢ã§ã™ã€‚\n:sprintã¯å¤‰æ•°ã®è©•ä¾¡ã‚’â€è¡Œã‚ãšã«â€ãã®å†…å®¹ã‚’è¡¨ç¤ºã™ã‚‹æ©Ÿèƒ½ã€‚ã“ã‚Œã‚’ä½¿ãˆã°ã‚µãƒ³ã‚¯ã®ã¾ã¾è©°ã¾ã‚Œã¦ã„ã¦ã¾ã è©•ä¾¡ã•ã‚Œã¦ã„ãªã„éƒ¨åˆ†ã‚‚ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã‚‹\n\nlet x = 1 + 2 :: Int\n\n:sprint x\n\nx = _\n\n\n\nâ†‘ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã¯ã‚µãƒ³ã‚¯ã‚’è¡¨ã—ã¦ãŠã‚ŠxãŒã¾ã è©•ä¾¡ã•ã‚Œã¦ã„ãªã„ã“ã¨ãŒåˆ†ã‹ã‚‹\n\nx\n\n:sprint x\n\n3\n\n\nx = 3\n\n\n\nâ†‘xãŒè©•ä¾¡ã•ã‚ŒãŸã®ã§ä¸­èº«ã‚‚è¦‹ãˆã‚‹ã‚ˆã†ã«ãªã£ãŸ\næ¬¡ã¯å¤‰æ•°ãŒå¤‰æ•°ã‚’å‚ç…§ã—ã¦ã„ã‚‹ä¾‹\n\nx = 1 + 2 :: Int\ny = x + 1\n\n:sprint x\n:sprint y\n\nx = _\n\n\n\ny = _\n\n\n\n\nseq y ()\n\n:sprint x\n:sprint y\n\n()\n\n\nx = 3\n\n\n\ny = 4\n\n\n\nâ†‘seqã‚’ä½¿ã†ã¨ç¬¬ä¸€å¼•æ•°ãŒå¼±é ­éƒ¨æ­£è¦å½¢ï¼ˆæœ€åˆã®æ§‹æˆå­ãŒè¦‹ãˆã‚‹ã¨ã“ã‚ï¼‰ã¾ã§å¼·åˆ¶çš„ã«è©•ä¾¡ã•ã‚Œã‚‹\n\nx = 1 + 2 :: Int\nz = (x, x)\n\n:sprint z\n\nz = _\n\n\n\nã‚ã‚Œï¼Ÿã“ã‚Œã¯ã¸ã„ã¸ã„Haskellã§ã¯ z = (_, _) ã¨è¦‹ãˆã‚‹ã¯ãšãªã‚“ã ã‘ã©é•ã†çµæœã«ãªã£ã¦ã—ã¾ã£ãŸã€‚\n\nimport Data.Tuple\n\nz = swap (x, x + 1)\n\n:sprint z\n\nz = _\n\n\n\n\nseq z ()\n\n:sprint z\n\n()\n\n\nz = (_,_)\n\n\n\nâ†‘ä»Šåº¦ã¯ã†ã¾ãã‚¿ãƒ—ãƒ«ã®æ§‹æˆå­ãŒè¦‹ãˆã‚‹ã¨ã“ã‚ã¾ã§è©•ä¾¡ã•ã‚ŒãŸ\n\nseq x ()\n\n:sprint z\n\n()\n\n\nz = (_,3)\n\n\n\nâ†‘xã ã‘è©•ä¾¡ã™ã‚‹ã¨3ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚zãŒè©•ä¾¡ã•ã‚Œã¦ã„ãªã„ã®ã§x + 1ã®éƒ¨åˆ†ã¯ã‚µãƒ³ã‚¯_ã®ã¾ã¾ã§ã‚ã‚‹\nä»Šåº¦ã¯ãƒªã‚¹ãƒˆã¨ map ã‚’ä½¿ã£ãŸã¨ãã®æŒ™å‹•ã‚’è¦‹ã¦ã¿ã‚‹\n\nxs = map (+1) [1..10] :: [Int]\n\n:sprint xs\n\nxs = _\n\n\n\n\nseq xs ()\n\n:sprint xs\n\n()\n\n\nxs = _ : _\n\n\n\nâ†‘:ã¯ãƒªã‚¹ãƒˆã®æ§‹æˆå­ãªã®ã§ã“ã“ãŒå¼±é ­éƒ¨æ­£è¦å½¢\n\nlength xs\n\n:sprint xs\n\n10\n\n\nxs = [_,_,_,_,_,_,_,_,_,_]\n\n\n\nâ†‘lengthã¯ä¸­èº«ã‚’è©•ä¾¡ã—ãªã„ã®ã§æ§‹é€ ã ã‘ãŒè©•ä¾¡ã•ã‚Œã¦ä¸­ã¯ã‚µãƒ³ã‚¯ã®ã¾ã¾\n\nsum xs\n\n:sprint xs\n\n65\n\n\nxs = [2,3,4,5,6,7,8,9,10,11]\n\n\n\nâ†‘ã“ã‚Œã§å…¨éƒ¨è©•ä¾¡ã•ã‚ŒãŸ\n:sprint ã‚’ä½¿ã†ã¨Haskellã®é…å»¶è©•ä¾¡ã§ä½•ãŒã©ã“ã¾ã§è©•ä¾¡ã•ã‚Œã‚‹ã®ã‹ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ã«åˆ†ã‹ã‚‹ã®ã§é¢ç™½ã„ã€‚"
  },
  {
    "objectID": "posts/2020-03-29/index.html",
    "href": "posts/2020-03-29/index.html",
    "title": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè£…ã—ã¦ã¿ãŸ",
    "section": "",
    "text": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã®å®Ÿè£…ã‚’é›£ã—ãã†ã‹ãªã¨æ€ã£ã¦ã„ã‚‹æ–¹ãŒã€ãªã‚“ã ç°¡å˜ã˜ã‚ƒãªã„ã§ã™ã‹ï¼ï¼ ã¨ãªã‚‹ãŸã‚ã®å®Ÿè£…è¬›åº§ã§ã™ ã¨ã„ã†è¨˜äº‹ãŒåˆ†ã‹ã‚Šã‚„ã™ã‹ã£ãŸã®ã§Haskellã§ã‚‚å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸ"
  },
  {
    "objectID": "posts/2020-03-29/index.html#é›¢æ•£ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›",
    "href": "posts/2020-03-29/index.html#é›¢æ•£ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›",
    "title": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè£…ã—ã¦ã¿ãŸ",
    "section": "é›¢æ•£ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›",
    "text": "é›¢æ•£ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›\nã¾ãšã¯æ™®é€šã®ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè£…ã—ã¾ã™\n\nimport Data.Complex\n\nfourierTransform :: RealFloat a =&gt; [Complex a] -&gt; [Complex a]\nfourierTransform xs =\n  let n = length xs\n      f aj i j = aj * cis (2 * pi * fromIntegral (i * j) / fromIntegral n)\n   in flip map [0..n-1] $ \\i -&gt; foldr (\\(j, aj) -&gt; (+) (f aj i j)) 0 (zip [0..] xs)\n\ninverseFourierTransform :: RealFloat a =&gt; [Complex a] -&gt; [Complex a]\ninverseFourierTransform xs =\n  let n = length xs\n      f aj i j = aj * cis (-2 * pi * fromIntegral (i * j) / fromIntegral n)\n   in flip map [0..n-1] $ \\i -&gt; foldr (\\(j, aj) -&gt; (+) (f aj i j)) 0 (zip [0..] xs) / fromIntegral n\n\nå…ƒã«æˆ»ã‚‹ã“ã¨ã‚’ç¢ºèªã€‚ã“ã‚Œã¯æ°—ãŒå‘ã„ãŸã‚‰QuickCheckã§æ›¸ãç›´ã—ãŸã„\n\ninverseFourierTransform $ fourierTransform [1, 2, 3, 4]\n\n[1.0000000000000002 :+ 5.551115123125783e-16,2.0 :+ 3.885780586188048e-16,3.0 :+ 5.551115123125783e-17,4.0 :+ (-3.3306690738754696e-16)]"
  },
  {
    "objectID": "posts/2020-03-29/index.html#é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›",
    "href": "posts/2020-03-29/index.html#é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›",
    "title": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè£…ã—ã¦ã¿ãŸ",
    "section": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›",
    "text": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›\né«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã¯ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã®è¨ˆç®—ã‚’åˆ†å‰²ã—ã¦å†å¸°çš„ã«è¨ˆç®—ã™ã‚‹ã®ã§é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¨ç›¸æ€§ãŒè‰¯ã•ãã†ã‹ãªã¨æ€ã£ãŸã‘ã©å®Ÿè£…ã¯æ³¥è‡­ã„æ„Ÿã˜ã«ãªã‚Šã¾ã—ãŸã€‚ã†ã¾ã„ã‚„ã‚Šæ–¹ã¨ã‹ã‚ã£ãŸã‚‰Twitterã§ã“ã£ãã‚Šæ•™ãˆã¦ä¸‹ã•ã„\nã‚ã¨å˜ç´”ãªå®Ÿè£…ãªã®ã§2ã®ç´¯ä¹—ã®é•·ã•ã®ãƒªã‚¹ãƒˆã§ã—ã‹ã†ã¾ãè¡Œã‹ãªã„ã‚„ã¤ã§ã™ã€‚\n\nimport Control.Arrow\n\nsplitEvenOdd :: [a] -&gt; ([a], [a])\nsplitEvenOdd = (reverse *** reverse) . go ([], [])\n  where go x [] = x\n        go (xs, ys) [x] = (x:xs, ys)\n        go (xs, ys) (x:y:zs) = go (x:xs, y:ys) zs\n\nmapTuple2 :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)\nmapTuple2 f (a1, a2) = (f a1, f a2)\n\nfastFourierTransform :: RealFloat a =&gt; [Complex a] -&gt; [Complex a]\nfastFourierTransform []  = error \"The length of list must be the power of 2.\"\nfastFourierTransform [x] = [x]\nfastFourierTransform xs  =\n  let n = length xs\n      (bs, cs) = mapTuple2 fastFourierTransform $ splitEvenOdd xs\n      atN2 xs i = xs !! (i `mod` (n `div` 2))\n      f i = bs `atN2` i + cs `atN2` i * cis (2 * pi * fromIntegral i / fromIntegral n)\n   in map f [0..n-1]\n\ninverseFastFourierTransform :: RealFloat a =&gt; [Complex a] -&gt; [Complex a]\ninverseFastFourierTransform xs = map (/ fromIntegral (length xs)) $ ifft xs\n  where\n    ifft []  = error \"The length of list must be the power of 2.\"\n    ifft [x] = [x]\n    ifft xs  =\n      let n = length xs\n          (bs, cs) = mapTuple2 ifft $ splitEvenOdd xs\n          atN2 xs i = xs !! (i `mod` (n `div` 2))\n          f i = bs `atN2` i + cs `atN2` i * cis (-2 * pi * fromIntegral i / fromIntegral n)\n       in map f [0..n-1]\n\nã“ã‚Œã‚‚å…ƒã«æˆ»ã‚‹ã“ã¨ã‚’ç¢ºèª\n\ninverseFastFourierTransform $ fastFourierTransform [1,2,3,4]\n\n[1.0 :+ 4.057416247971343e-16,2.0 :+ 9.385873628418619e-17,3.0 :+ 8.411709486180696e-17,4.0 :+ (-2.1632341619892149e-16)]"
  },
  {
    "objectID": "posts/2020-03-29/index.html#å®Ÿé¨“ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿",
    "href": "posts/2020-03-29/index.html#å®Ÿé¨“ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿",
    "title": "é«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè£…ã—ã¦ã¿ãŸ",
    "section": "å®Ÿé¨“ï¼šãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿",
    "text": "å®Ÿé¨“ï¼šãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿\nå®Ÿè£…ã—ãŸFFTã§ã†ã¾ãå‘¨æ³¢æ•°ã®ç©ºé–“ã«å¤‰æ›ã§ãã¦ã‚‹ã®ã‹ç¢ºèªã—ã¾ã™ã€‚ä½å‘¨æ³¢ã¨é«˜å‘¨æ³¢ã‚’åˆæˆã—ãŸä¿¡å·ã‚’ä½œæˆã—ã€ä½å‘¨æ³¢æˆåˆ†ã ã‘å–ã‚Šå‡ºã—ã¦ã¿ã¾ã™ã€‚\n\nimport Graphics.Rendering.Chart.Easy\n\nsignal :: [Double]\nsignal = map (\\i -&gt; sin (2 * pi * fromIntegral i / 32) + sin (2 * pi * fromIntegral i / 512)) [1..2048]\n\ntoRenderable $ plot (line \"sigmal\" [zip [0..] signal])\n\n\n\n\n\n\n\n\nå®Ÿè¡Œã—ãŸé«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã§å¤‰æ›ã—ã¦å‘¨æ³¢æ•°ç©ºé–“ã§ã®æ§˜å­ã‚’ç¢ºèª\n\nfSignal :: [Complex Double]\nfSignal = fastFourierTransform $ map (:+ 0) signal\n\nfSignalR, fSignalI :: [Double]\nfSignalR = map realPart fSignal\nfSignalI = map imagPart fSignal\n\ntoRenderable $ do\n    plot (line \"fSignalR\" [zip [0..] fSignalR])\n    plot (line \"fSignalI\" [zip [0..] fSignalI])\n\n\n\n\n\n\n\n\nãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ã¯ã€ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã—ã¦å…ˆé ­ã‹ã‚‰Nå€‹ã®æˆåˆ†ä»¥å¤–ã‚’0ã«ã—ã¦é€†ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã™ã‚‹ã‚ˆã†ã«å®Ÿè£…ã™ã‚‹\næƒ³å®šé€šã‚Šã«ä½å‘¨æ³¢æˆåˆ†ã ã‘å–ã‚Šå‡ºã™ã“ã¨ãŒã§ããŸã€‚ãªã‚“ã ç°¡å˜ã˜ã‚ƒãªã„ã§ã™ã‹ï¼ï¼\n\nconsider :: Num a =&gt; Int -&gt; [a] -&gt; [a]\nconsider _ []     = []\nconsider 0 xs     = replicate (length xs) 0\nconsider n (x:xs) = x : consider (n-1) xs\n\nlowPassFilter :: Int -&gt; [Double] -&gt; [Double]\nlowPassFilter n = map realPart . inverseFastFourierTransform . consider n . fastFourierTransform . map (:+ 0)\n\nsignal' :: [Double]\nsignal' = lowPassFilter 10 signal\n\ntoRenderable $ plot (line \"signal'\" [zip [0..] signal'])\n\n\n\n\n\n\n\n\né«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã€å®Œå…¨ã«ç†è§£ã—ãŸã€‚"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Haskellã§QRåˆ†è§£ã‚’å®Ÿè£…ã™ã‚‹\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMay 12, 2024\n\n\nlotz\n\n\n\n\n\n\n\n\n\n\n\n\nHaskellã§å®Ÿè£…ã™ã‚‹k-meansæ³•ã¨k-means++æ³•\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMar 23, 2024\n\n\nlotz\n\n\n\n\n\n\n\n\n\n\n\n\né«˜æ¬¡å…ƒç©ºé–“ã§ã¯L1è·é›¢ã‚’ä½¿ã†ã®ãŒè‰¯ã•ãã†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJul 11, 2020\n\n\nlotz\n\n\n\n\n\n\n\n\n\n\n\n\n2ç‚¹ãƒ†ã‚¤ãƒ©ãƒ¼å±•é–‹ã®å®šç¾©ã¨æ•°å€¤å®Ÿé¨“\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJul 9, 2020\n\n\nlotz\n\n\n\n\n\n\n\n\n\n\n\n\nHaskellã®éåŒæœŸå‡¦ç†ã‚’ä½¿ã£ãŸå…¥å‡ºåŠ›ã®é‡ã­åˆã‚ã›\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJun 29, 2020\n\n\nlotz\n\n\n\n\n\n\n\n\n\n\n\n\nGHCi ã® :sprint ãŒä¾¿åˆ©\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApr 12, 2020\n\n\nlotz\n\n\n\n\n\n\n\n\n\n\n\n\né«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè£…ã—ã¦ã¿ãŸ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMar 29, 2020\n\n\nlotz\n\n\n\n\n\n\nNo matching items"
  }
]